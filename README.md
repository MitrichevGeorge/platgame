# платформер в python
## для начала про pygame
1. В начале(ну после `import pygame`) всегда надо писать `pygame.init()`
2. Далее задать размер окна - `pygame.display.set_mode(([ШИРИНА], [ВЫСОТА]))` и эта функция возвращает объект `pygame.Surface`, представляющий главное окно игры, в котором ты рисуешь всё, что будет отображаться на экране. Он нам пригодится, так что кладём в переменную
3. Далее цикл игры - `while True:`
4. Далее опрос событий. Мы его сделаем простеёшим образом:
   ```python
   for e in pygame.event.get():
        if e.type == pygame.QUIT:
            exit()
   ```
   Этот цикл проходится по всем событиям и реагирует только на событие закрытия окна
5. Затем сама игра
6. Затем обновление экрана(отобразить изменения которые мы сделали до этогов цикле):
   ```python
   pygame.display.flip()
   ```
7. Затем задержка. Зачем она нужна? Ну вот один и тот же код без задержки:

   https://github.com/user-attachments/assets/5fd0fab4-e90a-4390-a3ab-731b4fdf8dc3

   И с задержкой:
   
   https://github.com/user-attachments/assets/ec702f72-cc4b-43a9-81fc-2a6fa4142171
   
   Надеюсь так понятен смысл.
   Для контроля скорости нам надо написать перед `while True`:
   ```python
   clock = pygame.time.Clock()
   ```
   это создаст сам счётчик - то есть уже встроенный алгоритм ограничивающий fps.
   И надо написать внутри цикла в конце него:
   ```python
   clock.tick([FPS])
   ``` 
   Где `[FPS]` - максимальная граница чатсоты кадров которую мы хотим задать.
   
   Но надо учитывать что это просто обрезает слишком высокий fps, но ни как не решает низкий. То есть если наш график фпс такой:
   ![Untitled diagram _ Mermaid Chart-2025-07-13-132208](https://github.com/user-attachments/assets/1fb192cf-8bc2-4a30-8b49-1d88be91d03c)
   <sub>Синим обозначен сам график фпс</sub>

   И если мы его ограничим до `60 fps` (зелёная линия), график fps станет примерно таким:
   ![Untitled diagram _ Mermaid Chart-2025-07-13-133038](https://github.com/user-attachments/assets/db2cbdc9-37f6-422a-a164-eadbb6da8d92)
   То есть останутся провалы fps **ниже** заданного порога. А вот если ограничим до `40 fps` (красная линия) - вот тогда он уже станет равномерным.
### Минимальный код pygame
Ну как следствие, из того что я выше расписал, мы можем написать основу кода использующего `pygame`:
```python
import pygame

pygame.init()  # 1. Инициализация pygame

WIDTH, HEIGHT = 800, 600
screen = pygame.display.set_mode((WIDTH, HEIGHT))  # 2. создание окна
clock = pygame.time.Clock()  # 7. Счётчик для ограничения FPS

while True:  # 3. Главный цикл игры
    for e in pygame.event.get():  # 4. Обработка событий
        if e.type == pygame.QUIT:
            exit()

    screen.fill((30, 30, 30))  # 5. Логика и отрисовка (я просто написал очистку экрана)
    
    pygame.display.flip()  # 6. Обновляем экран

    clock.tick(60)  # 7. Ограничение FPS до 60
```
## Базовый код платформера
Для начала напишем тот минимум который уже можно называть платформером.

1. Будем использовать объект `pygame.Rect`, хранящий сразу прямоугольник который легко отрисовать используя
   ```python
   pygame.draw.rect(screen, color, r)
   ```
   где `color` - цвет заливки представленный в виде `(r, g, b)`
   и `r` - сам объект класса `pygame.Rect`, ккоторый мы хотим отрисовать.

   Его будем использовать пока только для хранения позиции игрока(ну и сразу же для отрисовки) - будем хранить в глобальной переменной `player`.
2. Глобальные переменные:
   - `vel_y` - скорость игрока по y
     Будем использовать для вычисления фазики:
     ```python
     vel_y += g
     y += vel_y
     ```
     <sub>Где `g` - ускорение свободного падения(в пкс/кадр<sup>2</sup>), 'y' - координата y грока</sub>

     Эта формула соответствует правилам физики.
   - `gravity` - константа, просто значение ускорения свободного падения, соответствует силе гравитации
   - `floor_y` - расположение пола(нижнего края, ниже которого не может упасть игрок)
   - `touch` - булевый флаг(`True`/`False`) обозначающий в пределах одной итерации цикла, касается лиигрок поверхности - нужен чтобы прыжок был возможен только от пола(в последущем, платформы) и не был возможен в воздухе.

### Вот, собственно, код:

```python
import pygame
pygame.init()

screen = pygame.display.set_mode((800, 600))
clock = pygame.time.Clock()

player = pygame.Rect(100, 100, 50, 50)#чтоб не париться используем готовый объект pygame

vel_y = 0 #скорость по y
gravity = 0.5 #ускорение свободного падения
floor_y = 500 #позиция пола
touch = False #касается ли игрок пола(или поверхности) - для прыжка

while True:
    # 1. обработка хитбоксов
    touch = False
    # player.x и player.y - координаты левого верхнего угла
    # а нам нужен его нижний край - player.y + player.height
    if player.y + player.height > floor_y: #если игрок касается пола
        player.y = floor_y - player.height
        vel_y = 0
        touch = True

    # 2. ввод
    for e in pygame.event.get():
        if e.type == pygame.QUIT:
            exit()

    keys = pygame.key.get_pressed() #список состояний клавиш
    if keys[pygame.K_LEFT]:
        player.x -= 5
    if keys[pygame.K_RIGHT]:
        player.x += 5
    if keys[pygame.K_SPACE]:
        if touch: # прыжок только если игрок касается пола
            vel_y = -20 #просто меняем его скорость

    # 3. обновление
    if (not touch): vel_y += gravity # падение в воздухе
    player.y += vel_y

    # 4. рендер
    screen.fill((0,0,0))
    pygame.draw.rect(screen, (0, 100, 255), player) #рисуем игрока
    pygame.draw.rect(screen, (0, 200, 0), (0, floor_y, 800, 100))  #рисуем пол
    pygame.display.flip()
    clock.tick(60)
```
Запустим его:
![w1](https://github.com/user-attachments/assets/ab447101-d77a-4e8c-bece-3c7ca452205a)

## Улучшения
Далее я буду поэтапно вносить изменения, чтобы был ясен их смысл и логика.
Для быстрой промотки к нужной части(при перечитывании) можешь использовать список глав. Вот так выглядит кнопка чтоб его открыть(она в правом верхнем углу):
<img width="1946" height="1116" alt="image" src="https://github.com/user-attachments/assets/25e3ef2f-5499-41d1-9ae7-49ccc67bd372" />

### Управление

   



